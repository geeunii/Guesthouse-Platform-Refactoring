# 🔍 검색 로직 문서 (Search Logic Documentation)

이 문서는 **서버 사이드 필터링(Server-Side Filtering)**으로 마이그레이션된 현재 검색 기능의 로직을 설명합니다.

## 🏗 아키텍처 개요 (Architecture Overview)

모든 검색 조건 처리를 **서버(API)**가 담당하는 **단일 소스 방식**입니다:
1.  **통합 요청**: 검색어, 날짜, 테마뿐만 아니라 **가격 범위, 인원 수** 조건까지 모두 API 요청에 포함하여 전송합니다.
2.  **서버 응답**: DB에서 모든 조건에 부합하는 결과를 필터링하고 페이지네이션하여 반환합니다.
3.  **클라이언트 렌더링**: 서버에서 받은 결과를 추가 가공 없이 그대로 화면에 표시합니다.

---

## 🔄 데이터 흐름 (Data Flow)

### 1. 상태 관리 (Search Store)
`useSearchStore`가 모든 필터 값(가격, 인원 포함)을 관리합니다.

### 2. API 호출 (`loadList`)
-   **Trigger**: 필터 값 변경 시(가격 슬라이더 조작 후 등), `List.vue`의 `watch`가 동작하여 API를 호출합니다.
-   **Parameters**:
    ```javascript
    searchList({
      themeIds,
      keyword,
      checkin,
      checkout,
      guestCount,  // [NEW] 서버로 전송
      minPrice,    // [NEW] 서버로 전송
      maxPrice,    // [NEW] 서버로 전송
      page,
      size
    })
    ```

### 3. 결과 처리
-   서버는 이미 조건에 맞는 데이터만 포함된 페이지(`items`)와 정확한 전체 개수(`totalCount`)를 반환합니다.
-   클라이언트는 `items.value`를 그대로 렌더링합니다. (`filteredItems` 로직 제거됨)

---

## ✅ 개선된 점 (Improvements)

### 1. 페이지네이션 정합성 확보 (핵심)
-   **Before**: 서버에서 10개를 받고 클라이언트에서 가격으로 거르면 0개가 될 수 있음. (다음 페이지에 맞는 방이 있어도 못 봄)
-   **After**: 서버가 조건에 맞는 방만 찾아 10개를 채워서 보내주므로, **"조건에 맞는데 안 보이는" 문제가 완벽히 해결**되었습니다.

### 2. 대용량 데이터 성능 최적화
-   클라이언트 브라우저에서 많은 데이터를 반복문(`filter`)으로 처리할 필요가 없어졌습니다.
-   DB 인덱싱을 활용하여 수만 건의 데이터 중 조건에 맞는 항목을 빠르게 검색합니다.

### 3. UI/UX 일관성
-   헤더의 `totalCount`와 실제 리스트 개수가 항상 일치합니다.
-   빈 화면(Empty State)이 "서버에 데이터가 정말 없을 때"만 노출되므로 신뢰도가 향상되었습니다.

---

## ⚠️ 참고 사항

-   **네트워크 요청 증가**: 필터를 변경할 때마다 API 패킷이 발생하므로, 슬라이더 조작 시 `debounce`(입력 지연 대기) 처리가 사용자 경험에 중요할 수 있습니다.
